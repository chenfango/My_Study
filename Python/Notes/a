#!/bin/env python2.7
# coding:utf-8
## Author:              JiangZQ
## Version:             1.5
## Create date:         2013.8.10
## Update date:         2013.11.14
## Update date:         2013.12.02   add env['APP_NAME'] and env['TAG'] before run ./releas.sh
## Update date:         2015.01.16   add kettle support
## update date:         2015.12.24   utf-8 BOM file header problem
import os
import sys
reload(sys)
sys.setdefaultencoding("utf-8")

import shutil
import fnmatch
import argparse
import colorful
import re
import json
from system import run
import datetime
import urllib2
import cStringIO
import ConfigParser
import io
import time
import codecs

GIT_BIN='/usr/local/bin/git'
GRADLE_PATH='/wls/programs/gradle-1.0-milestone-3/bin'
JAVA_HOME='/wls/programs/jdk1.6.0_32'
JAVA_6_HOME = '/wls/programs/jdk1.6.0_32'
JAVA_8_HOME = '/wls/programs/jdk1.8.0_51'
JAVA_7_HOME = '/wls/programs/jdk1.7.0_79'
SOURCE_BASE_PATH='/wls/source'
v'/wls/release'
RELEASE4REG_BASE_PATH='/wls/release4reg'
PE_HELPER_URL='http://172.17.40.64:8000/pe/build.do'
DBCM_CHECK_TAG_URL = 'http://bettle.lujs.cn/service/check_tag.do'
NASFILE_BASE_PATH = '/wls/nasfile'
TAG_PATTERN = re.compile('^(dev|hot|reg|mok|emp|quick)_(?P<date>\d{8})_\d{2}$')
DBCM_CHECK_TAG_URL_NEW = 'http://bettle.lujs.cn/service/webrequest?username=jenkins&secret_key=2d2c2d4aa4c1a026a7dfdaf9cb324808&method=app_build_check&'
MAVEN_PATH='/wls/programs/apache-maven-3.0.5/bin'
MAVEN_C_PATH='/wls/programs/apache-maven-3.5.0/bin'


class CaseSensitiveConfigParser(ConfigParser.RawConfigParser):
    def optionxform(self, optionstr):
        return optionstr

class ConfigHandle2:
    """
    分析配置文件
    """
    def __init__(self, content, is_file=True):
        if is_file:
            self._init_config_by_path(content)
        else:
            self._init_config_by_content(content)

    def _init_config_by_path(self, path):
        """
        发布说明解析器
        :param path: 发布说明的完整路径
        :return: 解析好的发布说明
        """
        if not os.path.isfile(path):
            raise IOError('配置文件 {0} 不存在'.format(path))
        self._path = path
        self._msg = ""

        configContent = None
        try:
            # x = open(self._path)
            # 为应对 BOM File Header 问题，需要使用 codecs 的 open 去除 BOM 的影响。
            ### BOM 常见于 Windows notepad 另存为 UTF8 时被偷偷加上
            x = codecs.open(self._path, 'rb', 'utf_8_sig')
            configContent = cStringIO.StringIO()
            for line in x.readlines():
                configContent.write(line.lstrip())
            x.close()
            configContent.flush()
            config = CaseSensitiveConfigParser(allow_no_value=True)
            self.config = config
            config.readfp(io.BytesIO(configContent.getvalue()))

        except ConfigParser.MissingSectionHeaderError:
            self._msg = "不是认可的INI文件"
        except Exception, e:
            self._msg = "解析配置文件异常, exception: {0}; \n {1}".format(e.message, traceback.format_exc())
        finally:
            if configContent is not None:
                configContent.close()

    def _init_config_by_content(self, content):
        """
        发布说明解析器
        :param path: 发布说明的完整路径
        :return: 解析好的发布说明
        """
        # windows对于utf-8编码的文件自带BOM，但是其他系统utf-8编码默认不带BOM
        # 判断字符串的头, 如果包含BOM, 则去除
        if content.startswith(codecs.BOM_UTF8):
            self._content = content.replace(codecs.BOM_UTF8, "")
        else:
            self._content = content

        self._configContent = None
        self._msg = ''
        try:
            self._configContent = cStringIO.StringIO()
            self._configContent.write(self._content)
            self._configContent.flush()
            config = CaseSensitiveConfigParser(allow_no_value=True)
            self.config = config
            config.readfp(io.BytesIO(self._configContent.getvalue()))

        except ConfigParser.MissingSectionHeaderError:
            self._msg = "不是认可的INI文件"
            print self._msg
        except Exception, e:
            self._msg = "解析配置文件异常, exception: {0}; \n {1}".format(e.message, traceback.format_exc())
        finally:
            if self._configContent is not None:
                self._configContent.close()

    def get_config_key(self, section):
        """
        通过SECTION获取对应的内容
        :param section:
        :return: list
        """
        has_section = self.config.has_section(section)
        if not has_section:
            return ''

        try:
            val = self.config.options(section)
            return val
        except Exception, ex:
            self._msg = ex.message
            return ''

    def get_config_value(self, section, key):
        """
        获取ITEM的内容
        :param section:
        :return: str
        """
        has_section = self.config.has_section(section)
        if not has_section:
            return ''

        val = None
        for opStr in self.config.options(section):
            if opStr.upper() != key.upper():
                continue
            val = self.config.get(section, opStr)

        return val

    def get_config_sections(self):
        """
        get sections
        :return:
        """
        return self.config.sections()

    def get_config_sections_content(self, section):
        """
        get sections content
        :return:
        """
        if self.config.has_section(section):
            return self.config.options(section)
        else:
            return None

class Repo(object):
    def __init__(self, application_name):
        self.application_name = application_name
        self.source_path = '%s/%s' % (SOURCE_BASE_PATH, self.application_name)
        self.build_path = '%s/build/deploy' % self.source_path
        self.tagPattern = TAG_PATTERN
        self.tag = 'master'

    def __enter__(self):
        self._changeDir()
        return self

    def __exit__(self, *args):
        self._changeDir(True)

    def _changeDir(self, p=None, back=False):
        path = p or self.source_path
        assert path is not None
        if back:
            os.chdir(self.oldcwd)
            print colorful.yellow('change to %s' % self.oldcwd)
        else:
            self.oldcwd = os.getcwd()
            os.chdir(path)
            print colorful.green('change to %s' % path)

    @staticmethod
    def clone(application_name, url):
        # 这里的 application_name 要转成对应的 GIT 上的仓库地址
        run('%s clone %s %s/%s' % (GIT_BIN, url, SOURCE_BASE_PATH, application_name), raise_error=True)

    def cloneAllApp(self):
        self.oldcwd = os.getcwd()
        os.chdir(SOURCE_BASE_PATH)
        print colorful.yellow('chang to %s'%SOURCE_BASE_PATH)
        gitAppList = ['common.app', 'common.web','common.scheduler', 'p2p.app', 'p2p.web', 'market-app', 'market-web', 'wcm', 'xinbao-app', 'site', 'static', 'infrastructure.app', 'list-app', 'list-web', 'user-app', 'user-web', 'mq.app', 'trading-app', 'trading-web', 'settle-app', 'plan-app', 'gateway.app', 'gw.tenpay', 'audit-app', 'be-report-app', 'be-report-web', 'be-opr-app', 'be-opr-web', 'be-cs-app', 'be-cs-web', 'be-market-app', 'be-market-web', 'be-capital-app', 'be-capital-web', 'be-admin-app', 'be-admin-web', 'be-fa-app', 'be-fa-web', 'cif-web', 'anshuo-app', 'gw.anshuo', 'mobile-app', 'mobile-web', 'session-app', 'gw.mobile', 'contract-app', 'fa-app', 'cal-app', 'cal-web', 'fund.app', 'fund.web', 'account.app', 'security-app', 'security-web', 'my-app', 'my-web', 'ucs-app', 'search-app', 'search-web', 'ccb-gw', 'cashier-app', 'cashier-web', 'accountr-app', 'yeb-gw', 'yeb-app', 'yeb-web']
        count = 0
        while count<len(gitAppList):
            gitCmd = '%s clone git@172.17.40.1:%s'% (GIT_BIN,gitAppList[count])
            print colorful.green('(%s) %s'%(count+1,gitCmd))
            run(gitCmd, raise_error=True)
            count = count + 1
        print colorful.green('Total: %s applications'%count)
        os.chdir(self.oldcwd)
        print colorful.yellow('chang back to %s'%self.oldcwd)

    def pull(self):
        #print colorful.green('>>> >>> run %s pull' % GIT_BIN)
        print colorful.green('>>> >>> run %s fetch --all && %s reset --hard origin/master' % (GIT_BIN,GIT_BIN))
        #更新tag不需要pull 当前分支 因此去掉
        #run('%s pull' % GIT_BIN, raise_error=True)
        run('%s fetch --all' % GIT_BIN, raise_error=True)
        run('%s reset --hard origin/master' % GIT_BIN, raise_error=True)
        # 失败也不要影响主流程
        #run('%s fetch --tags ' % GIT_BIN)

    def rpull(self):
        #print colorful.green('>>> >>> run %s pull' % GIT_BIN)
        print colorful.green('>>> >>> run %s fetch --all && %s reset --hard origin/master' % (GIT_BIN,GIT_BIN))
        #run('%s pull' % GIT_BIN, raise_error=True)
        run('%s fetch --all' % GIT_BIN, raise_error=True)
        run('%s reset --hard origin/master' % GIT_BIN, raise_error=True)
        #run('%s fetch --tags ' % GIT_BIN)

    def allow_build(self, tag):
        tag_prefix = tag[0:4]
        bettle = self.getBettleIdFromReleaseNote(self.get_release_file(tag))
        print bettle

        if tag_prefix in ("hot_", "reg_", "emp_"):
            # 限制 reg 变为 reg emp hot 三种可能上线的 TAG
            try:
                for retry_times in range(2):
                    #url = '%s?app=%s&tag=%s' % (DBCM_CHECK_TAG_URL, self.application_name, tag)
                    url = '%sapp=%s&tag=%s&bettle=%s' %(DBCM_CHECK_TAG_URL_NEW, self.application_name, tag, bettle)
                    print url
                    white_list = ['rcn-kettle','anshuo-job-app','intl-mq-app','intl-kmq-app','identity-app','intl-lscheduler-app','be-kettle','cmb-gw','org-order-app','contract-ext-app','wcm']
                    if self.application_name in white_list:
                        return True
                    response = urllib2.urlopen(url, timeout=20)
                    r = response.read().strip()
                    print r
                    if response.code == 200:
                        response_json = json.loads('{'+r.split('{')[-1])
                        allow = response_json.get('result', 'False')
                        if allow == 'True':
                        #if True:
                            print colorful.green("{0}/{1} bettle new allow build".format(self.application_name, tag))
                            return True
                        else:
                            print colorful.red("{0}/{1} bettle new deny build, reason: {2}".format(self.application_name, tag, response_json.get('msg', '')))
                    elif response.code == 404:
                        # bettle 这个功能没有上线
                        return True
                    else:
                        print colorful.red('meet unknow error( %s )' % url)
                        print colorful.red("HTTP code %s" % response.code)
                        print colorful.red("%s " % response.read())
                    time.sleep(15)
                return False
            except Exception, e:
                print e
                print colorful.red('DBCM service call failed(%s,%s)' % (self.application_name, tag))
                return False
        else:
            return True

    def unBuildTags(self, days):
        self._changeDir()
        self.checkout('master')
        self.rpull()

        startFlag = int((datetime.datetime.now() - datetime.timedelta(days=days)).strftime('%Y%m%d'))
        for line in os.popen('%s tag' % GIT_BIN).readlines():
            # 符合规范的 tag
            tag = line.strip()
            print tag
            m = self.tagPattern.match(tag)
            if m:
                # tag 日期在1个月内
                #print "TAG : %s is valid"%tag
                #print startFlag, int(m.group("date"))
                if int(m.group("date")) >= startFlag:
                    # 在 release 目录没有发现build记录的
                    #print "TAG : %s is in time"%tag
                    releasePath = self.get_app_tag_release_path(tag)
                    if not os.path.exists(releasePath):
                        #print "TAG : %s is not jenkinsBuild yet"%tag
                        #print tag

                        if not self.allow_build(tag):
                            continue

                        try:
                            emails =  eval(open('app_email.json').read())
                            email = emails.get(self.application_name, 'liwanwei370@pingan.com.cn').replace('|', ' ')
                        except:
                            email = 'liwanwei370@pingan.com.cn'
                        try:
                            url = '%s?app=%s&tag=%s&email=%s'%(PE_HELPER_URL, self.application_name, tag, email)
                            print url
                            response = urllib2.urlopen(url, timeout=10)
                            if response.code == 200:
                                print 'call %s success'%url
                            elif response.code == 404:
                                print 'application %s not exists'%self.application_name
                            else:
                                print 'meet unknow error( %s )'%url
                                print "HTTP code %s"%response.code
                                print "%s "%response.read()
                        except Exception, e:
                            print e
                            print 'call pe helper failed(%s,%s)'%(self.application_name, tag)

        # self._changeDir(True)

    def checkout(self, tag):
        print colorful.green('>>> >>> run %s checkout -f %s' % (GIT_BIN, tag))
        try:
            run('%s checkout -f %s' % (GIT_BIN, tag), raise_error=True)
        except:
            #run('%s pull' % (GIT_BIN), raise_error=False)
            run('%s fetch --all' % GIT_BIN, raise_error=True)
            run('%s reset --hard origin/master' % GIT_BIN, raise_error=True)
            print colorful.red('!!! ERROR git checkout -f <tag>!!! ')
            print colorful.red("请检查 TAG {0} 是否存在，或 TAG 是否已 push ")
            exit(1)

        verPath = ['%s/src/main/webapp/' % self.source_path,
                   '%s/src/main/resources/ver/' % self.source_path,
                   '%s' % self.source_path]
        for _verPath in verPath:
            if not os.path.exists(_verPath):
                os.makedirs(_verPath)
                print colorful.yellow('create directory %s' % _verPath)
            wfile = open('%s/ver.txt' % _verPath, 'w')
            wfile.write('%s' % tag)
            wfile.close()

    def status(self):
        print colorful.green('>>> >>> run %s status' % GIT_BIN)
        run('%s status' % GIT_BIN)

    def clean(self):
        print colorful.green('>>> >>> run %s clean -df' % GIT_BIN)
        run('%s clean -df' % GIT_BIN, raise_error=True)

    def compile(self,tag):
        if 'JAVA_HOME' not in os.environ:
            os.environ['JAVA_HOME'] = JAVA_HOME
        if GRADLE_PATH not in os.environ['PATH']:
            os.environ['PATH'] = '%s:%s' % (os.environ['PATH'], GRADLE_PATH)
        if MAVEN_PATH not in os.environ['PATH']:
            os.environ['PATH'] = '%s:%s' % (os.environ['PATH'], MAVEN_PATH)
        os.environ['JAVA_7_HOME'] = JAVA_7_HOME
        os.environ['APP_NAME'] = self.application_name
        os.environ['JAVA_6_HOME'] = JAVA_6_HOME
        os.environ['JAVA_8_HOME'] = JAVA_8_HOME
        os.environ['MAVEN_C_PATH'] = MAVEN_C_PATH
        os.environ['ENVIRONMENT'] = 'dev'
        os.environ['TAG'] = tag
        print colorful.green("app:{0} tag:{1}".format(self.application_name, self.tag))
        print colorful.green("="*80)
        print colorful.green('>>> >>> rm ./.gradle/ ./build/ ')
        # kill some gradle bug here
        run('rm -rf ./.gradle/ ./build/ ', shell=True)

        print colorful.green('>>> >>> run ./release.sh')
        run('chmod +x ./release.sh', shell=True, raise_error=True)
        try:
            run('./release.sh', shell=True, raise_error=True)
        except:
            print colorful.red("release.sh 执行出错， build 失败，详情请看日志")
            raise
        print colorful.green('<<< <<< run ./release.sh')
        print colorful.green("="*80)

    def build(self, tag):
        self.tag = tag
        try:
            self._changeDir()
            self.clean()
            self.checkout('master')
        except:
            print colorful.red("操作 git 本地 repo 时出错(命令 git checkout master)")
            sys.exit(1)

        try:
            self.rpull()
            self.checkout(tag)
        except:
            print colorful.red("操作 git 本地 repo 时出错(命令 git pull --tag ; git checkout {0})".format(tag))
            sys.exit(1)

        if not self.release_file_exists(tag):
            print colorful.red(
                "移交物所必须的发布说明文件 {0} 不存在，build 过程不能启动".format(self.get_release_file(tag))
            )
            print colorful.red(
                "建立 release 空目录 {0} 防止重复 build ".format(self.get_app_tag_release_path())
            )
            self.create_app_tag_release_path()
            return False
        else:
            release_file = self.get_release_file(tag)
            print colorful.green(
                "移交物检查： release {0} 文件通过".format(release_file)
            )

        if not os.path.isfile(self.get_release_sh()):
            print colorful.red(
                "移交物所必须的执行文件 {0} 不存在，build 过程不能启动".format(self.get_release_sh())
            )
            print colorful.red(
                "建立 release 空目录 {0} 防止重复 build ".format(self.get_app_tag_release_path())
            )
            self.create_app_tag_release_path()
            return False
        else:
            print colorful.green(
                "移交物检查：release.sh 检查通过"
            )

        if not self.allow_build(tag):
            print colorful.red(
                "{0}/{1} 的 build 过程因未在 bettle.lujs.cn 完成 SQL Review 而终止， 请找 DBA 进行 SQL Review".format(self.application_name, tag))
            print colorful.red(
                "可以访问 http://bettle.lujs.cn/sqlreview/?app={0} 查看 SQL Review 的情况".format(self.application_name))
            return False
        else:
            print colorful.green(
                "移交物检查：bettle sqlreview 检查通过"
            )

        if self.application_name.endswith("kettle"):
            print colorful.green("{0} is a kettle application, it need check all sections".format(self.application_name))
            if  not self.isKettleInfoOKFromReleaseNote(release_file):
                return False

        print colorful.green(
            "移交物检查未见异常，开始 build "
        )

        try:
            self.compile(tag)
        except:
            print colorful.red("compile 失败")
            print colorful.red(
                "建立 release 空目录 {0} 防止重复 build ".format(self.get_app_tag_release_path())
            )
            self.create_app_tag_release_path()
            return False
        return True

    def getReleaseFiles(self, tag):
        def config_filter(filename):
            name, ext = os.path.splitext(filename)
            if ext == '.xml':
                if name == 'dataSource':
                    return True
            elif ext == '.properties':
                if name.endswith('-env'):
                    return False
                elif name == 'log4j':
                    return False
                elif name == 'log4js':
                    return False
                else:
                    return True
            elif ext == '.js':
                return True
            elif ext == '.json':
                return True
            else:
                return False

        build_path = self.build_path
        package_file = '%s/%s.war' % (build_path, self.application_name) if os.path.isfile('%s/%s.war' % (build_path, self.application_name)) else ''

        if os.path.exists(build_path) and os.path.isdir(build_path):
            if len(package_file) == 0:
                package_file = '%s/%s.jar' % (build_path, self.application_name) if os.path.isfile('%s/%s.jar' % (build_path, self.application_name)) else ''
            if len(package_file) == 0:
                package_file = '%s/%s.tar' % (build_path, self.application_name) if os.path.isfile('%s/%s.tar' % (build_path, self.application_name)) else ''

            config_files = map(lambda x: '%s/config/%s' % (build_path, x), filter(config_filter, os.listdir('%s/config' % build_path))) if os.path.isdir('%s/config' % build_path) else []

            static_files = ['%s/%s' % (build_path, static_file) for static_file in fnmatch.filter(os.listdir(build_path), '*.zip')]
        else:
            print colorful.red("常规release产出目录 {0} 不存在".format(build_path))
            config_files = []
            static_files = []

        release_file = self.get_release_file(tag)

        if not self.release_file_exists(tag):
            raise IOError('Release file not found: %s' % release_file)
        return package_file, config_files, static_files, release_file

    def get_release_file(self, tag):
        """
        代码根目录/release/$tag_date_part$.txt
        :param tag:
        :return:
        """
        release_file = '%s/release/%s.txt' % (self.source_path, tag.split('_')[1])
        return release_file

    def get_release_sh(self):
        """
        代码根目录/release/release.sh
        :param tag:
        :return:
        """
        release_sh = '%s/release.sh' % (self.source_path)
        return release_sh

    def release_file_exists(self, tag):

        release_file = self.get_release_file(tag)
        return os.path.exists(release_file)

    def packNasFile(self, srcPath, release_path, hash=None, tag=None, file_type='NASFILE', appkey=None):
        position = hash or tag
        # 对NAS file 打包
        executor_number = os.environ.get('EXECUTOR_NUMBER', '0')
        nasFilePath = os.path.join(NASFILE_BASE_PATH, executor_number)
        colorful.yellow("{0} reposity path : {1}".format(nasFilePath, file_type))
        # 使用 jenkins  $EXECUTOR_NUMBER 隔离目录，防止并发build引发问题
        self._changeDir(p=nasFilePath)
        self.clean()
        self.checkout('master')
        self.pull()
        if position:
            self.checkout(position)
        else:
            # 没有指定位置就使用最新的
            pass
        self.createNasFileZipVerInfoFile(srcPath, tag)
        self.createNasFileZip(srcPath, release_path, file_type=file_type, appkey=appkey)
        #self._changeDir(back=True)

    def check_already_release(self, tag):
        release_path = self.get_app_tag_release_path()
        if os.path.exists(release_path) and os.listdir(release_path):
            if os.path.exists(release_path + '/apps/{}.war'.format(self.application_name)):
                print colorful.yellow("{}已经存在了, 不需要重复构, 如果需要重新构建，请先删除该目录".format(release_path))
                return True
            elif not os.path.exists(release_path + '/apps'):
                return True
            else:
                print "好像之前构建过,但是失败了"
                return False
        else:
            print "还没有构建，可以重新构建"
            return False

    def packKettleFile(self, kettle_info_path):
        """
        创建 kettle 的zip包
        :param release_path:
        """
        verInfoPath = "{0}/build.info.txt".format(kettle_info_path)
        verInfo = open(verInfoPath, mode="w")
        verInfo.write("build_date:{}\n".format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))))
        verInfo.write("create_by:{0}/{1}\n".format(self.application_name, self.tag))
        verInfo.close()
        print self.source_path
        cmd = "cd {0} ; mkdir -p {1};zip -r {1}/KETTLE-{2}.zip {3}   -x *.git/  -x *.svn/  ".format(self.source_path, self.build_path,
                                                               kettle_info_path.replace('/', '_'),
                                                               kettle_info_path)
        print cmd
        run(cmd=cmd, shell=True)

    def packAndCpAzkaban(self, release_path):
        """
        针对pd-kettle应用，打包pd-kettle的azkaban目录到zip
        """
        cmd = "cd {0} ; zip -r {1}-azkaban.zip azkaban".format(self.source_path, self.application_name)
        print cmd
        run(cmd=cmd, shell=True)
        shutil.copy("{0}/{1}-azkaban.zip".format(self.source_path, self.application_name), release_path)

    def createNasFileZipVerInfoFile(self, srcPath, tag=None):
        """
        NASFILE 的zip包内生成版本信息
        :param srcPath:
        :param tag:
        """
        (cdPath, packPath) = os.path.split(srcPath.strip('/'))
        if cdPath == '':
            cdPath = packPath
            packName = cdPath.strip().split('_')[-1]
        else:
            packName = packPath

        verInfoPath = "{0}/{1}.info.txt".format(cdPath, packPath)
        verInfo = open(verInfoPath, mode="w+")
        verInfo.write("build_date:{}\n".format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))))
        verInfo.write("create_by:{0}/{1}\n".format(self.application_name, self.tag))
        if tag:
            verInfo.write("nasfile_tag:{0}\n".format(tag))
        verInfo.write("nasfile_hash:")
        verInfo.close()
        run(cmd="{0} log --pretty=format:'%H' -n 1 | xargs echo >> {1}".format(GIT_BIN, verInfoPath), shell=True)

    def createNasFileZip(self, srcPath, release_path, file_type='NASFILE', appkey=None):
        """
        为 NASFILE 创建 zip 包
        :param srcPath:
        :param release_path:
        :rtype : object
        """
        (cdPath, packPath) = os.path.split(srcPath.rstrip('/'))
        if cdPath == '':
            cdPath = packPath
            packName = cdPath.strip().split('_')[-1]
            packPath = './'
        else:
            packName = packPath
            packPath = '%s/ %s.info.txt' % (packPath, packName)
        if not appkey:
            # NASFILE 中添加应用名 rel_20150917_contract
            appkey = cdPath.split('_')
            if len(appkey) >= 3:
                appkey = appkey[2]
            else:
                appkey = None
        if appkey:
            cmd = "cd {0} ; zip -r {2}/{3}-{1}-{4}_{5}.zip {6}  -x *.git/  -x *.svn/  ".format(
                cdPath, packName, release_path, file_type, appkey, self.application_name, packPath)
        else:
            cmd = "cd {0} ; zip -r {2}/{3}-{1}_{4}.zip {5}  -x *.git/  -x *.svn/ ".format(
                cdPath, packName, release_path, file_type, self.application_name, packPath)

        print colorful.green("    begin create zip file")
        print colorful.green("    current dir : {}".format(os.path.abspath('.')))
        print colorful.green("    {}".format(cmd))
        run(cmd=cmd, shell=True)
        print colorful.green("    end create zip file")

    def _getClearConfigFromReleaseNote(self, releaseFilePath):
        """
        分析发布说明，转成清晰的Config
        :param releaseFilePath: CaseSensitiveConfigParser
        """
        # x = open(releaseFilePath)
        # 为应对 BOM File Header 问题，需要使用 codecs 的 open 去除 BOM 的影响。
        ### BOM 常见于 Windows notepad 另存为 UTF8 时被偷偷加上

        x = codecs.open(releaseFilePath, 'rb', 'utf_8_sig')
        configContent = cStringIO.StringIO()
        for l in x.readlines():
            line = l.strip()
            if line.startswith('[') and line.endswith(']'):
                line = line.upper()
                print colorful.green('SECTION: {0}'.format(line))
            configContent.write(line.lstrip())
            configContent.write("\n")
        x.close()
        configContent.flush()
        config = CaseSensitiveConfigParser(allow_no_value=True)
        config.readfp(io.BytesIO(configContent.getvalue()))
        return config

    def getNasFileInfoFromReleaseNote(self, releaseFilePath, section='NASFILE'):
        """
        针对声明 NASFILE,TFSFILE 的项目
        :param releaseFilePath:
        :return:
        """
        rtnList = []
        config = None
        try:
            config = self._getClearConfigFromReleaseNote(releaseFilePath)
        except Exception, ex:
            print colorful.red("  分析发布说明失败，这不是一个标准的发布说明，无法获取 %s 标签信息" % section)
            raise ex
            return []
        if not config.has_section(section):
            print colorful.green('  section [%s] not in release file,skip' % section)
            return []
        nasFilePathPattern = re.compile('^/?[\w-]+/[\w-]+/?$')
        if section == 'NASFILE':
            options = config.options(section)
        else:
            options = config.items(section)
        for nasFileOP in options:
            val = ''
            if section == 'TFSFILE':
                val = nasFileOP[1].split(',')[0]
                nasFileOP = nasFileOP[1].split('=')[1]
            if len(nasFileOP.split('_')) == 4:
                m = nasFilePathPattern.match('%s/%s' % ("_".join(nasFileOP.split('_')[0:3]).strip(), nasFileOP.split('_')[3].strip()))
                print colorful.green("打印pattern %s/%s" % ("_".join(nasFileOP.split('_')[0:3]).strip(), nasFileOP.split('_')[3].strip()))
            else:
                m = nasFilePathPattern.match(nasFileOP.strip())
            if m:
                print colorful.green("找到 {0} 声明目录: {1}".format(section, nasFileOP))
                if section == 'NASFILE':
                    val = config.get(section, nasFileOP) or ''
                arr = (nasFileOP.strip() + ' ' + val.strip()).split()
                if len(arr) >= 2:
                    (srcPath, position) = (arr[0], arr[1])
                else:
                    (srcPath, position) = (arr[0], 'master')
                rtnList.append((srcPath, position))
                print colorful.yellow("  {0} path: {1}, git position '{2}'".format(section, srcPath, position))
            else:
                print colorful.red("  {0} path:{1} invalid , skip".format(section, nasFileOP))
        return rtnList

    def getBettleIdFromReleaseNote(self, releaseFilePath):
        """
        读取release note 里面的bettle id
        """
        try:
            config = self._getClearConfigFromReleaseNote(releaseFilePath)
        except:
            print colorful.red("  分析发布说明失败，这不是一个标准的发布说明，无法获取 KETTLE 标签信息")
            return ''
        bettles = []
        try:
            if config.get('DB1', 'bettle'):
                bettles.append(config.get('DB1', 'bettle'))
        except:
            pass
        try:
            if config.get('DB2', 'bettle'):
                bettles.append(config.get('DB2', 'bettle'))
        except:
            pass

        return ",".join(bettles)

    def getKettleInfoFromReleaseNote(self, releaseFilePath):
        """
        针对 kettle 类项目
        :param releaseFilePath: 发布说明的路径
        """
        rtnList = []
        try:
            config = self._getClearConfigFromReleaseNote(releaseFilePath)
        except:
            print colorful.red("  分析发布说明失败，这不是一个标准的发布说明，无法获取 KETTLE 标签信息")
            return []

        if not config.has_section('KETTLE'):
            print colorful.green('  section [KETTLE] not in release file,skip')
            return []
        for kettleOP in config.options('KETTLE'):
            if os.path.isdir(kettleOP):
                print colorful.green("  找到 KETTLE 声明目录：{0}".format(kettleOP))
                rtnList.append(kettleOP)
            else:
                print colorful.red("  KETTLE 声明目录不存在：{0}，忽略".format(kettleOP))

        return rtnList

    def isKettleInfoOKFromReleaseNote(self, releaseFilePath):
        """
        针对 kettle 类项目 检查kettleInfo is complete
        :param releaseFilePath: 发布说明的路径
        """
        kettle_config_need_tag = [
            "DEP",
            "NASFILE",
            "DB1",
            "DB2",
            "NOTIFY",
            "ADVICE",
            "CRONTAB",
            "AZKABAN_PROJECT",
            "AZKABAN_SCHEDULE",
            "OOZIE",
            "KETTLE",
            "ALARM"
        ]

        try:
            config_handle = ConfigHandle2(releaseFilePath, is_file=True)
            sections = config_handle.get_config_sections()
            minus_tag = list(set(kettle_config_need_tag).difference(set(sections)))
            if len(minus_tag) > 0:
                print colorful.red("kettle应用发布说明标签错误, 标签 {0} 必填.".format(minus_tag))
                return False
            check_flag = True
            for section in kettle_config_need_tag:
                sec_content = config_handle.get_config_sections_content(section)
                if sec_content is None or len(sec_content) <= 0:
                    check_flag = False
                    print colorful.red("{0} 标签无内容, 违反kettle发布说明发版规则".format(section))
                else:
                    if section.upper() == "NOTIFY":
                        has_mail = False
                        for content in sec_content:
                            if content.find("@lu.com") >= 0 or content.find("@pingan.com.cn") >= 0:
                                has_mail = True
                                break

                        if not has_mail:
                            check_flag = False
                            print colorful.red("NOTIFY 标签没有填写联系人邮箱, 违反kettle发布说明发版规则".format(section))

            if not check_flag:
                print colorful.red("kettle 说明不完整，必须包含 DEP NASFILE DB1 DB2 NOTIFY ADVICE CRONTAB AZKABAN_PROJECT AZKABAN_SCHEDULE OOZIE KETTLE ALARM")
                return False
            else:
                return True
        except Exception, e:
            print  colorful.red("{0}/{1} readme file parser exception [{2}]".format(app, tag, e))
            return False

    def addNasFileZipToRelease(self, nasFileInfoList, release_path, section='NASFILE'):
        """
        将 NASFILE 的ZIP包放置 release 目录下
        :param nasFileInfoList:
        :param release_path:
        """
        hashPattern = re.compile("[\dabcdef]{40}")
        for (srcPath, position) in nasFileInfoList:
            if self.tagPattern.match(position):
                # 这是一个 tag
                print colorful.yellow('    process NASFILE {0}, tag:{1}'.format(srcPath, position))
                self.packNasFile(srcPath, release_path, tag=position)
                continue
            if hashPattern.match(position):
                # 这是一个 hash
                print colorful.yellow('    process NASFILE {0}, hash:{1}'.format(srcPath, position))
                self.packNasFile(srcPath, release_path, hash=position)
                continue
            if position == 'master':
                print colorful.red('    process NASFILE {0}, master(latest version)'.format(srcPath, position))
                self.packNasFile(srcPath, release_path)
                continue
            if section == 'TFSFILE':
                # 这是一个tfs包
                self.packNasFile(srcPath, release_path, file_type=section, appkey=position)

    def get_app_tag_release_path(self, tag=None):
        tag = tag or self.tag
        release_path = '%s/%s/%s' % (RELEASE_BASE_PATH, self.application_name, tag)
        return release_path

    def create_app_tag_release_path(self):
        # 创建 relase 时需要放置的目录
        release_path = self.get_app_tag_release_path()
        if os.path.exists(release_path):
            shutil.rmtree(release_path)

        os.makedirs(release_path)
        return release_path

    def release(self, tag):
        # 首先建一个空目录，防止失败的 jenkinsBuild 一直触发 jenkins
        release_path = self.create_app_tag_release_path()

        package_file, config_files, static_files, release_file = self.getReleaseFiles(tag)

        # 处理 NASFILE,TFSFILE
        for section in ['NASFILE', 'TFSFILE']:
            print colorful.green('开始处理标签 %s' % section)
            nasFileInfoList = self.getNasFileInfoFromReleaseNote(release_file, section=section)
            if len(nasFileInfoList) == 0:
                print colorful.green('  未声明 %s 标签或该标签下无符合条件的内容' % section)
            else:
                for p in nasFileInfoList:
                    print colorful.green('  {0} path : {1}'.format(section, p))
                self.addNasFileZipToRelease(nasFileInfoList, release_path, section=section)
            print colorful.green('结束处理标签 %s' % section)

        # 处理 KETTLE
        print colorful.green('开始处理标签 KETTLE')
        kettleInfoList = self.getKettleInfoFromReleaseNote(release_file)
        if len(kettleInfoList) == 0:
            print colorful.green('  未声明 KETTLE 标签或该标签下无符合条件的内容')
        else:
            for p in kettleInfoList:
                print colorful.green('  KETTLE path : {0}'.format(p))
                self.packKettleFile(p)
        print colorful.green('结束处理标签 KETTLE')

        package_file, config_files, static_files, release_file = self.getReleaseFiles(tag)

        # 发布说明
        shutil.copy(release_file, release_path)
        if self.application_name in ['pd-kettle', 'rcn-kettle','simulation-kettle','cal-kettle','jijin-kettle','intl-kettle','ail-kettle','risk-compute-kettle','ps-kettle'] and os.path.exists(os.path.join(self.source_path,'azkaban')):
            self.packAndCpAzkaban(release_path)
        if package_file:
            os.mkdir('%s/apps' % release_path)
            shutil.copy(package_file, '%s/apps' % release_path)
            print colorful.green('Package File: %s' % package_file)

        if config_files:
            os.mkdir('%s/config' % release_path)
            print colorful.green('Config Files:')
            for config_file in config_files:
                shutil.copy(config_file, '%s/config' % release_path)
                print colorful.green("copy {0} into {1}".format(config_file, release_path))

        if static_files:
            for static_file in static_files:
                shutil.copy(static_file, release_path)
            print colorful.green('Static Files: %s' % ' '.join(static_files))

        print colorful.green('Release File: %s' % release_file)
        print colorful.green('Release Path: %s' % release_path)

        return release_path


def showMenu():
    def drawMenu(lst, title=None):
        if title:
            print colorful.green(title)
        for i, item in enumerate(lst):
            print '%3s> %s' % (i+1, item)
        return lst[getChoice(len(lst))-1]

    def getChoice(max_length):
        while 1:
            try:
                choice = raw_input(colorful.green('Enter [1-%s], q for exit: ' % max_length)).strip()
            except KeyboardInterrupt:
                print
                sys.exit()
            if choice == 'q':
                sys.exit()
            try:
                choice = int(choice)
                if not 0 < choice <= max_length:
                    raise Exception
            except:
                print colorful.red('Invalid Input!')
                continue
            else:
                return choice

    application_list = os.listdir(SOURCE_BASE_PATH)
    application_list.sort()
    appname = drawMenu(application_list, 'Select an application:')
    print
    while 1:
        try:
            tag = raw_input(colorful.green('Enter a tag: ')).strip()
        except KeyboardInterrupt:
            print
            sys.exit()
        if tag:
            break
        else:
            print colorful.red('Invalid Input!')
            continue
    return appname, tag


def main():
    if len(sys.argv) == 1:
        appname, tag = showMenu()
        sys.argv.append(appname)
        sys.argv.append(tag)
    parser = argparse.ArgumentParser(description='Build & Release application', epilog='Powered by Jiang Zhiqiang,killkill ')
    parser.add_argument('-c', '--create', dest='create', action='store_true', help='Create an application repo')
    parser.add_argument('-a', '--all', dest='all', action='store_true', help='Create all applications')
    parser.add_argument('-p', '--polling', dest='polling', action='store_true', help='polling all tags , find out which should be jenkinsBuild ')
    parser.add_argument('appname', metavar='AppName', help='AppName')
    parser.add_argument('tag', metavar='Tag', help='Tag or git url(-c) or days(-t)')
    args = parser.parse_args()
    tag_pattern = TAG_PATTERN
    if not args.create and not args.polling and tag_pattern.match(args.tag) is None:
        print colorful.red("不规范的TAG号:{0}，拒绝build".format(args.tag))
        sys.exit(1)
    if os.getuid() == 0:
        print colorful.red('run by root is not good practice')
        #sys.exit(0)
    if args.create:
        Repo.clone(args.appname, args.tag)
        sys.exit(0)
    if args.polling:
        repo = Repo(args.appname)
        repo.unBuildTags(int(args.tag))
        sys.exit(0)
    if args.all:
        print colorful.green('Clone all apps from git@172.17.40.1 ......')
        repo = Repo(args.appname)
        repo.cloneAllApp()
        sys.exit(0)
    else:
        repo = Repo(args.appname)
        if not os.path.isdir(repo.source_path):
            print >> sys.stderr, colorful.red('Directory %s not found.' % repo.source_path)
            sys.exit(1)

        print colorful.yellow('Build %s ...' % repo.application_name)
        success = repo.build(args.tag)
        if success:
            print
            print colorful.yellow('Releasing %s ...' % repo.application_name)
            returnval = repo.release(args.tag)
            cmd2 = '''curl "http://lujs.cn/lts/brood/interfaceapp/callback_op_jenkins_build_tag?appName=%s&tag=%s"''' % (args.appname, args.tag)
            run (cmd2)
            print colorful.green('call %s' % cmd2)
            print colorful.green('Done')
            if os.path.isdir(returnval):
                exit(0)
            else:
                exit(1)
        else:
            exit(1)


if __name__ == "__main__":
    main()

